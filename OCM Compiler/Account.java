// Automatically Generated by OCM - The Object Cassandra Mapper
//
// Any changes made to this file may be overwritten without warning!


package com.kissintelligentsystems.ocm.java.sample.generated;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Random;

import me.prettyprint.cassandra.service.Keyspace;

import org.apache.cassandra.service.Column;
import org.apache.cassandra.service.ColumnParent;
import org.apache.cassandra.service.ColumnPath;
import org.apache.cassandra.service.NotFoundException;
import org.apache.cassandra.service.SlicePredicate;
import org.apache.cassandra.service.SliceRange;
import org.apache.cassandra.service.SuperColumn;
import org.apache.thrift.TException;

import com.kissintelligentsystems.ocm.java.BaseTable;
import com.kissintelligentsystems.ocm.java.BaseTableScanner;
import com.kissintelligentsystems.ocm.java.DynamicSuperFamily;
import com.kissintelligentsystems.ocm.java.Many2Many;
import com.kissintelligentsystems.ocm.java.OCMConnection;

@SuppressWarnings("unused")
public class Account extends BaseTable
{
	//Shared Byte arrays of various column and filed names
	private static byte[] familyNameBytes;
	
	//Get each Super Families Name in Bytes
	private static byte[] infoSuperNameBytes;

	private static byte[] usersSuperNameBytes;
	private static byte[] usersAccountsForeignNameBytes;
		
	//Get each Fields name in bytes
	private static byte[] infoNameNameBytes;
	
		
	//Key Field
	protected String accountID;
		
	//Info Fields
	protected String name;

	//Dynamic Super Family Fields

	//Many 2 Many Columns
	protected Many2Many<User> users;


	//Field Changed Flags
	private boolean name_Changed = false;

	//Original Indexed Fields

	//The OHM Connection
	private OCMConnection connection;

		
	public Account(OCMConnection connection, String accountID)
	{
		//Store the key field
		this.accountID = accountID;
			
		//Store the connection
		this.connection = connection;
		
		//Initialise all the Dynamic Column Families

		//Initialise all the Many 2 Many Columns
		users = new Many2Many<User>();

		//Check if we need to initialise all the shared values
		if(familyNameBytes == null)
		{
			//Convert the Column Family name
			familyNameBytes = fromString("Accounts");	

			//Convert each super column name
			infoSuperNameBytes = fromString("info");
			usersSuperNameBytes = fromString("users");
			usersAccountsForeignNameBytes = fromString("accounts");
			
			//Convert each fields name
			infoNameNameBytes = fromString("name");

		}

	}
		
	@Override
	public void newKey(Random rand) throws Exception
	{
		//Get the DB Interface to generate a new key
		accountID = generateNewKey(connection, familyNameBytes, rand);
	}
		

	//Index Accessor Methods
	public void delete() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				

			//Delete the other side of all the Many 2 Many relationships
			Enumeration<String> enumeration = null;
			

			//Make sure the column is recently loaded
			loadUsers();

			enumeration = users.getColumns().keys();
				
			while (enumeration.hasMoreElements())
			{
				//Remove the foreign key
				keyspace.remove(enumeration.nextElement(), new ColumnPath("Users",  usersAccountsForeignNameBytes, fromString(accountID)));
			}

			//Delete the actual row
			keyspace.remove(accountID, new ColumnPath("Accounts",null, null));
			
		}
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public void loadAll() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate(null, new SliceRange(new byte[0], new byte[0], false, 10000));

			List<SuperColumn> data = keyspace.getSuperSlice(accountID, new ColumnParent("Accounts", null), pred);
								
			//Load the fields from the returned data
			loadAll(data);
		}
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	public void loadAll(List<SuperColumn> data)
	{
		Iterator<SuperColumn> iterator = data.iterator();
	
		while(iterator.hasNext())
		{
			//Get each Super Column
			SuperColumn superCol = iterator.next();
		
			if(false)
			{
				//Used to assist code generation
			}
		
			else if(Arrays.equals(superCol.getName(), infoSuperNameBytes))
			{
				loadInfo(superCol.getColumns());
			}
			else if(Arrays.equals(superCol.getName(), usersSuperNameBytes))
			{
				loadUsers(superCol.getColumns());
			}
		}
	}
	
	

	public void loadInfo() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate(null, new SliceRange(new byte[0], new byte[0], false, 10000));
				
			List<Column> data  = keyspace.getSlice(accountID, new ColumnParent("Accounts", infoSuperNameBytes), pred);
	
			loadInfo(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadInfo(List<Column> cols)
	{

		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();

			if(false)
			{
				//Used to assist code generation
				
			}
	 		else if(Arrays.equals(col.getName(), infoNameNameBytes))
			{
					name = toString(col.getValue());
					name_Changed = false;
			}
		}
	}


	

	public void loadUsers() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate(null, new SliceRange(new byte[0], new byte[0], false, 10000));
				
			List<Column> data  = keyspace.getSlice(accountID, new ColumnParent("Accounts", usersSuperNameBytes), pred);
	
			loadUsers(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadUsers(List<Column> cols)
	{
		Dictionary<String, User> data = users.getColumns();
			
		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();
				
			//Get the key for the other Column Family
			String key = toString(col.getName());
				
			//Get each entry (Don't load it yet thats left to the user)
			User entry = new User(connection, key);
				
			//Add the entry
			data.put(key, entry);
		}
	}
	


	@Override
	public void save() throws Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
								
			ArrayList<SuperColumn> sups = new ArrayList<SuperColumn>();
			
			ArrayList<Column> cols = new ArrayList<Column>();
			
			if(name_Changed)
			{
				//Add the changed column
				cols.add(new Column(infoNameNameBytes, fromString(name), System.currentTimeMillis()));
		
				//Update the changed flag
				name_Changed = false;
			}
			
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(infoSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}				

			//Update Dynamic Columns
			Iterator<String> dynamicIterator = null;
			Enumeration<String> updatedKeys = null;
			

			//Update Many 2 Many Columns
			dynamicIterator = users.getDeletedColumns().iterator();

			while(dynamicIterator.hasNext())
			{
				String foreignKey = dynamicIterator.next();
					
				//Remove the column from this column family
				keyspace.remove(accountID, new ColumnPath("Accounts", usersSuperNameBytes, fromString(foreignKey)));
				
				//Remove this item from the other table
				keyspace.remove(foreignKey, new ColumnPath("Users", usersAccountsForeignNameBytes, fromString(accountID)));
			}

			updatedKeys = users.getUpdatedColumns().keys();

			while(updatedKeys.hasMoreElements())
			{
				String foreignKey = updatedKeys.nextElement();
					
				//Add it to this tables column
				cols.add(new Column(fromString(users.get(foreignKey).getKey()), new byte[0], System.currentTimeMillis()));
					
				//Add the other tables key to this item					
				keyspace.insert(users.get(foreignKey).getKey(), new ColumnPath("Users", usersAccountsForeignNameBytes, fromString(accountID)), new byte[0]);
			}
				
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(usersSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
				
				//Clear all the logged updates
				users.clearPendingUpdates();
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}
			

			//Check if there are any new inserts
			if(sups.size() > 0)
			{
				//Send all the value updates to the db
				LinkedHashMap<String, List<SuperColumn>> superMap = new LinkedHashMap<String, List<SuperColumn>>();
					
				//Add all the changes super columns for this Column Family
				superMap.put("Accounts", sups);
						
				//Send the Batch Insert to the DB Node
				keyspace.batchInsert(accountID, null, superMap);
			}
		}
					
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public String getKey()
	{
		return accountID;
	}
	
	//Key is read only
	public String getAccountID()
	{
		return accountID;
	}
		
	//Field Getter and Setters
	public String getName()
	{
		return name;
	}
			
	public void setName(String name)
	{
		this.name = name;
		
		//Update the changed flag
		name_Changed = true;
	}
	
			

	//Dynamic Columns can't be set

	//Many 2 Many Columns can't be set
	public Many2Many<User> getUsers()
	{
		return users;
	}



	public static AccountScanner getScanner(OCMConnection connection)
	{
		return new AccountScanner(connection);
	}
		
	public static class AccountScanner extends BaseTableScanner
	{			
		public AccountScanner (OCMConnection connection)
		{
			super(connection, "Accounts");
		}
			
		public void start(int limit, String key)
		{
			super.startWithStop(limit, key, "");
		}

		public void start(int limit, String startKey, String stopKey)
		{
			super.startWithStop(limit, startKey, stopKey);
		}

		public void start(String key)
		{
			super.startWithStop(-1, key, "");
		}
			
		public void start(String startKey, String stopKey)
		{
			super.startWithStop(-1, startKey, stopKey);
		}
			
			
		public Account tryGetNext() throws IllegalArgumentException, NotFoundException, Exception
		{
			RowData rowData = super.nextRow(); 
				
			if(rowData == null)
				return null;
				
			//Create a new user
			Account result = new Account(connection, rowData.getKey());
				
			//Load the results
			result.loadAll(rowData.getColumns());
								
			return result;
		}		
	}
}