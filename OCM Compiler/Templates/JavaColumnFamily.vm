// Automatically Generated by OCM - The Object Cassandra Mapper
//
// Any changes made to this file may be overwritten without warning!


package $package;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Random;

import me.prettyprint.cassandra.service.Keyspace;

import org.apache.cassandra.thrift.*;
import org.apache.thrift.TException;

import com.kissintelligentsystems.ocm.java.BaseTable;
import com.kissintelligentsystems.ocm.java.BaseTableScanner;
import com.kissintelligentsystems.ocm.java.DynamicSuperFamily;
import com.kissintelligentsystems.ocm.java.Many2Many;
import com.kissintelligentsystems.ocm.java.OCMConnection;

@SuppressWarnings("unused")
public class $className extends BaseTable
{
	//Shared Byte arrays of various column and filed names
	private static byte[] familyNameBytes;
	
	//Get each Super Families Name in Bytes
#foreach( $family in $families )
	private static byte[] $family.getName()SuperNameBytes;
#end
#foreach( $family in $dynamicFamilies )		
	private static byte[] $family.getName()SuperNameBytes;
#end

#foreach( $family in $many2ManyFamilies )		
	private static byte[] $family.getName()SuperNameBytes;
	private static byte[] ${family.getName()}${family.getFieldUpperCase()}ForeignNameBytes;
#end		
		
	//Get each Fields name in bytes
#foreach( $family in $families )
#foreach( $field in $family.getFields())
	private static byte[] $family.getName()$field.getNameUpperCase()NameBytes;
#end
#end
	
		
	//Key Field
	protected $keyField.getTypeName() $keyField.getName();
		
#foreach( $family in $families )
	//$family.getNameUpperCase() Fields
#foreach( $field in $family.getFields())
	protected $field.getTypeName() $field.getName();
#end

#end
	//Dynamic Super Family Fields
#foreach( $family in $dynamicFamilies )
	protected DynamicSuperFamily<$family.getTypeName()> $family.getName();
#end

	//Many 2 Many Columns
#foreach( $family in $many2ManyFamilies )
	protected Many2Many<$family.getEntityName()> $family.getName();
#end


	//Field Changed Flags
#foreach( $family in $families )
#foreach( $field in $family.getFields())
	private boolean $field.getName()_Changed = false;
#end

#end
	//Original Indexed Fields
#foreach( $family in $families )
#foreach( $field in $family.getFields())
#if( $field.isIndexed() )
	protected $field.getTypeName() $field.getName()_Original;
#end
#end
#end

	//The OHM Connection
	private OCMConnection connection;

		
	public $className(OCMConnection connection, $keyField.getTypeName() $keyField.getName())
	{
		//Store the key field
		this.$keyField.getName() = $keyField.getName();
			
		//Store the connection
		this.connection = connection;
		
		//Initialise all the Dynamic Column Families
#foreach( $family in $dynamicFamilies )
		$family.getName() = new DynamicSuperFamily<$family.getTypeName()>();
#end

		//Initialise all the Many 2 Many Columns
#foreach( $family in $many2ManyFamilies )
		$family.getName() = new Many2Many<$family.getEntityName()>();
#end

		//Check if we need to initialise all the shared values
		if(familyNameBytes == null)
		{
			//Convert the Column Family name
			familyNameBytes = fromString("$columnFamilyName");	

			//Convert each super column name
#foreach( $family in $families )
			$family.getName()SuperNameBytes = fromString("$family.getName()");
#end
#foreach( $family in $dynamicFamilies )		
			$family.getName()SuperNameBytes = fromString("$family.getName()");
#end	
#foreach( $family in $many2ManyFamilies )		
			$family.getName()SuperNameBytes = fromString("$family.getName()");
			${family.getName()}${family.getFieldUpperCase()}ForeignNameBytes = fromString("$family.getField()");
			
#end	
			//Convert each fields name
#foreach( $family in $families )
#foreach( $field in $family.getFields())
			$family.getName()$field.getNameUpperCase()NameBytes = fromString("$field.getName()");
#end

#end			
		}

	}
		
	@Override
	public void newKey(Random rand) throws Exception
	{
		//Get the DB Interface to generate a new key
		$keyField.getName() = generateNewKey(connection, familyNameBytes, rand);
	}
		

	//Index Accessor Methods
#foreach( $family in $families )
#foreach( $field in $family.getFields())
#if( $field.isIndexed() )
	public static $className tryGetFrom$field.getNameUpperCase()(String key, OCMConnection connection) throws Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			keyspace = connection.borrowKeySpace();
				
			//Use the index
			ColumnPath columnPath = new ColumnPath("${columnFamilyName}By${field.getNameUpperCase()}");
			columnPath.column = fromString("key");
			
			Column keyCol = keyspace.getColumn(key, columnPath);

			String index = toString(keyCol.getValue());
				
			//Create the new column
			return new $className(connection, index);
		}

		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
		
#end
#end
#end
	public void delete() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				

			//Delete the other side of all the Many 2 Many relationships
			Enumeration<String> enumeration = null;
			
#foreach( $family in $many2ManyFamilies )	

			//Make sure the column is recently loaded
			load${family.getNameUpperCase()}();

			enumeration = ${family.getName()}.getColumns().keys();
				
			while (enumeration.hasMoreElements())
			{
				//The Foreign Key
				ColumnPath columnPath = new ColumnPath("${family.getColumnFamily()}");
				columnPath.setSuper_column(${family.getName()}${family.getFieldUpperCase()}ForeignNameBytes);
				columnPath.column = fromString($keyField.getName());

				//Remove the foreign key
				keyspace.remove(enumeration.nextElement(), columnPath);
			}
#end

			//Delete the actual row
			keyspace.remove($keyField.getName(), new ColumnPath("${columnFamilyName}"));
			
		}
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public void loadAll() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));

			List<SuperColumn> data = keyspace.getSuperSlice($keyField.getName(), new ColumnParent("${columnFamilyName}"), pred);
								
			//Load the fields from the returned data
			loadAll(data);
		}
		finally
		{
			if(keyspace != null)
				connection.returnKeySpace(keyspace);
		}
	}
	
	public void loadAll(List<SuperColumn> data)
	{
		Iterator<SuperColumn> iterator = data.iterator();
	
		while(iterator.hasNext())
		{
			//Get each Super Column
			SuperColumn superCol = iterator.next();
		
			if(false)
			{
				//Used to assist code generation
			}
		
#foreach( $family in $families )
			else if(Arrays.equals(superCol.getName(), $family.getName()SuperNameBytes))
			{
				load${family.getNameUpperCase()}(superCol.getColumns());
			}
#end
#foreach( $family in $dynamicFamilies )
			else if(Arrays.equals(superCol.getName(), $family.getName()SuperNameBytes))
			{
				load${family.getNameUpperCase()}(superCol.getColumns());
			}
#end
#foreach( $family in $many2ManyFamilies )
			else if(Arrays.equals(superCol.getName(), $family.getName()SuperNameBytes))
			{
				load${family.getNameUpperCase()}(superCol.getColumns());
			}
#end
		}
	}
	
#foreach( $family in $families )
	

	public void load${family.getNameUpperCase()}() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("${columnFamilyName}");
			columnParent.setSuper_column(${family.getName()}SuperNameBytes);

			List<Column> data = keyspace.getSlice($keyField.getName(), columnParent, pred);
	
			load${family.getNameUpperCase()}(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void load${family.getNameUpperCase()}(List<Column> cols)
	{

		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();

			if(false)
			{
				//Used to assist code generation
				
			}
#foreach( $field in $family.getFields())
	 		else if(Arrays.equals(col.getName(), $family.getName()$field.getNameUpperCase()NameBytes))
			{
					$field.getName() = ${field.getToStringValue()}(col.getValue());
					$field.getName()_Changed = false;
#if( $field.isIndexed() )

					//Indexed Field
					$field.getName()_Original = $field.getName();
#end
			}
#end
		}
	}
#end		

#foreach( $family in $dynamicFamilies )
	

	public void load${family.getNameUpperCase()}() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
			
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("${columnFamilyName}");
			columnParent.setSuper_column(${family.getName()}SuperNameBytes);

			List<Column> data = keyspace.getSlice($keyField.getName(), columnParent, pred);

			load${family.getNameUpperCase()}(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void load${family.getNameUpperCase()}(List<Column> cols)
	{
		Dictionary<String, $family.getTypeName()> data =  ${family.getName()}.getColumns();
			
		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();
				
			//Add each value
			data.put(toString(col.getName()), ${family.getToStringValue()}(col.getValue()));
		}
	}
	
#end

#foreach( $family in $many2ManyFamilies )
	

	public void load${family.getNameUpperCase()}() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
			

			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("${columnFamilyName}");
			columnParent.setSuper_column(${family.getName()}SuperNameBytes);

			List<Column> data  = keyspace.getSlice($keyField.getName(), columnParent, pred);
	
			load${family.getNameUpperCase()}(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void load${family.getNameUpperCase()}(List<Column> cols)
	{
		Dictionary<String, $family.getEntityName()> data = ${family.getName()}.getColumns();
			
		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();
				
			//Get the key for the other Column Family
			String key = toString(col.getName());
				
			//Get each entry (Don't load it yet thats left to the user)
			$family.getEntityName() entry = new $family.getEntityName()(connection, key);
				
			//Add the entry
			data.put(key, entry);
		}
	}
	
#end


	@Override
	public void save() throws Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
								
			ArrayList<SuperColumn> sups = new ArrayList<SuperColumn>();
			
			ArrayList<Column> cols = new ArrayList<Column>();
			
#foreach( $family in $families )
#foreach( $field in $family.getFields())			
			if($field.getName()_Changed)
			{
				//Add the changed column
				cols.add(new Column($family.getName()$field.getNameUpperCase()NameBytes, $field.getFromStringValue()($field.getName()), System.currentTimeMillis()));
		
				//Update the changed flag
				$field.getName()_Changed = false;
#if( $field.isIndexed() )

				ColumnPath columnPath = new ColumnPath("${columnFamilyName}By${field.getNameUpperCase()}");
				columnPath.column = fromString("key");

				//Indexed Field
				if($field.getName()_Original != null)
				{
					try
					{
						//Remove the old index
						keyspace.remove($field.getName()_Original, columnPath);
					}
					catch(Exception exp)
					{
						//Ignore the exception as the key may have already been updated
					}
				}
					
				//Insert the new index
				keyspace.insert($field.getName(), columnPath, fromString($keyField.getName()));
#end			}
			
#end
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(${family.getName()}SuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}				
#end

			//Update Dynamic Columns
			Iterator<String> dynamicIterator = null;
			Enumeration<String> updatedKeys = null;
			
#foreach( $family in $dynamicFamilies )
			dynamicIterator = ${family.getName()}.getDeletedColumns().iterator();

			while(dynamicIterator.hasNext())
			{
				ColumnPath columnPath = new ColumnPath("${columnFamilyName}");
				columnPath.setSuper_column(${family.getName()}SuperNameBytes);
				columnPath.column = fromString(dynamicIterator.next());

				//Remove the column
				keyspace.remove($keyField.getName(), columnPath);
			}

			updatedKeys = ${family.getName()}.getUpdatedColumns().keys();

			while(updatedKeys.hasMoreElements())
			{
				String key = updatedKeys.nextElement();
					
				cols.add(new Column(fromString(key), ${family.getFromStringValue()}(roles.getColumn(key)), System.currentTimeMillis()));
			}
				
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Clear all the logged updates
				${family.getName()}.clearPendingUpdates();
			
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(${family.getName()}SuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}
			
#end

			//Update Many 2 Many Columns
#foreach( $family in $many2ManyFamilies )
			dynamicIterator = ${family.getName()}.getDeletedColumns().iterator();

			while(dynamicIterator.hasNext())
			{
				String foreignKey = dynamicIterator.next();
							
				ColumnPath localColumnPath = new ColumnPath("${columnFamilyName}");
				localColumnPath.setSuper_column(${family.getName()}SuperNameBytes);
				localColumnPath.column = fromString(foreignKey);

				//Remove the column from this column family
				keyspace.remove($keyField.getName(), localColumnPath);

				ColumnPath foriegnColumnPath = new ColumnPath("${family.getColumnFamily()}");
				foriegnColumnPath.setSuper_column(${family.getName()}${family.getFieldUpperCase()}ForeignNameBytes);
				foriegnColumnPath.column = fromString($keyField.getName());
	
				//Remove this item from the other table
				keyspace.remove(foreignKey, foriegnColumnPath);
			}

			updatedKeys = ${family.getName()}.getUpdatedColumns().keys();

			while(updatedKeys.hasMoreElements())
			{
				String foreignKey = updatedKeys.nextElement();
					
				//Add it to this tables column
				cols.add(new Column(fromString(${family.getName()}.get(foreignKey).getKey()), new byte[0], System.currentTimeMillis()));
					
				ColumnPath columnPath = new ColumnPath("${family.getColumnFamily()}");
				columnPath.setSuper_column(${family.getName()}${family.getFieldUpperCase()}ForeignNameBytes);
				columnPath.column = fromString($keyField.getName());

				//Add the other tables key to this item					
				keyspace.insert(${family.getName()}.get(foreignKey).getKey(), columnPath, new byte[0]);
			}
				
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(${family.getName()}SuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
				
				//Clear all the logged updates
				${family.getName()}.clearPendingUpdates();
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}
			
#end

			//Check if there are any new inserts
			if(sups.size() > 0)
			{
				//Send all the value updates to the db
				LinkedHashMap<String, List<SuperColumn>> superMap = new LinkedHashMap<String, List<SuperColumn>>();
					
				//Add all the changes super columns for this Column Family
				superMap.put("$columnFamilyName", sups);
						
				//Send the Batch Insert to the DB Node
				keyspace.batchInsert($keyField.getName(), null, superMap);
			}
		}
					
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public String getKey()
	{
		return $keyField.getName();
	}
	
	//Key is read only
	public $keyField.getTypeName() get${keyField.getNameUpperCase()}()
	{
		return $keyField.getName();
	}
		
	//Field Getter and Setters
#foreach( $family in $families )
#foreach( $field in $family.getFields())
	public $field.getTypeName() get${field.getNameUpperCase()}()
	{
		return $field.getName();
	}
			
	public void set${field.getNameUpperCase()}($field.getTypeName() ${field.getName()})
	{
		this.${field.getName()} = $field.getName();
		
		//Update the changed flag
		$field.getName()_Changed = true;
	}
	
			
#end

#end
	//Dynamic Columns can't be set
#foreach( $family in $dynamicFamilies )
	public DynamicSuperFamily<${family.getTypeName()}> get${family.getNameUpperCase()}()
	{
		return $family.getName();
	}
	
#end	

	//Many 2 Many Columns can't be set
#foreach( $family in $many2ManyFamilies )
	public Many2Many<${family.getEntityName()}> get${family.getNameUpperCase()}()
	{
		return $family.getName();
	}

#end	


	public static ${className}Scanner getScanner(OCMConnection connection)
	{
		return new ${className}Scanner(connection);
	}
		
	public static class ${className}Scanner extends BaseTableScanner
	{			
		public ${className}Scanner (OCMConnection connection)
		{
			super(connection, "${columnFamilyName}");
		}
			
		public void start(int limit, String key)
		{
			super.startWithStop(limit, key, "");
		}

		public void start(int limit, String startKey, String stopKey)
		{
			super.startWithStop(limit, startKey, stopKey);
		}

		public void start(String key)
		{
			super.startWithStop(-1, key, "");
		}
			
		public void start(String startKey, String stopKey)
		{
			super.startWithStop(-1, startKey, stopKey);
		}
			
			
		public ${className} tryGetNext() throws IllegalArgumentException, NotFoundException, Exception
		{
			RowData rowData = super.nextRow(); 
				
			if(rowData == null)
				return null;
				
			//Create a new user
			${className} result = new ${className}(connection, rowData.getKey());
				
			//Load the results
			result.loadAll(rowData.getColumns());
								
			return result;
		}		
	}
}
