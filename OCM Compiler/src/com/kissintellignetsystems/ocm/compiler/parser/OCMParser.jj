/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./OCMParser.jj */
/*@egen*/PARSER_BEGIN(OCMParser)

package com.kissintellignetsystems.ocm.compiler.parser;

import com.kissintellignetsystems.ocm.compiler.*;

import java.io.*;
import java.util.*;

public class OCMParser/*@bgen(jjtree)*/implements OCMParserTreeConstants/*@egen*/ 
{/*@bgen(jjtree)*/
  protected static JJTOCMParserState jjtree = new JJTOCMParserState();

/*@egen*/
}

PARSER_END(OCMParser)

    


// 2. Lexical specification

SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r")>
| "/*": IN_COMMENT 
}

// When any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > SKIP : {

    <  ~[] > }
      
// When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : {

    "*/": DEFAULT } 



/* Types */
TOKEN : {
	<BOOLEAN: "Boolean"> |
	<BYTE: "Byte"> |
	<BYTESTREAM: "ByteStream"> |
	<DOUBLE: "Double"> |
    <FLOAT: "Float"> |
	<INT: "Int"> |
	<LONG: "Long"> |
    <STRING: "String">    
}

/* Reserved Words */
TOKEN : {
	<SUPER_FAMILY: "SuperFamily"> |
	<DYNAMIC_SUPER_FAMILY: "DynamicSuperFamily"> |
	<MANY_2_MANY: "Many2Many"> |
	<KEY: "Key"> |
	<COLUMN_FAMILY: "ColumnFamily">
}


TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

TOKEN : {
 <LIT: <QUOTE> (<LETTER> | <DIGIT> | " ")* <QUOTE> >
}

/* Terminal Char */
TOKEN :
{
	< TERM : ";" >
}

TOKEN :
{
	< DOT : "." >
}

TOKEN :
{
	< EQUALS : "=" > | < QUOTE : "\"" >
}

/* Square Brackets */
TOKEN :
{
	< LEFT_SQUARE_BRACKET: "[" > | < RIGHT_SQUARE_BRACKET: "]" >
}

/* Braces */
TOKEN :
{
	< LEFT_BRACE: "{" > | < RIGHT_BRACE: "}" >
}

SimpleNode parse()             :{/*@bgen(jjtree) #OCMSpec(true) */
  ASTOCMSpec jjtn000 = new ASTOCMSpec(JJTOCMSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #OCMSpec(true) */
  try {
/*@egen*/
  (ColumnFamily())+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ColumnFamily()               : {/*@bgen(jjtree) ColumnFamily */
                                     ASTColumnFamily jjtn000 = new ASTColumnFamily(JJTCOLUMNFAMILY);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null; Token i = null; } 
{/*@bgen(jjtree) ColumnFamily */
  try {
/*@egen*/
  ((<LEFT_SQUARE_BRACKET> i=<IDENTIFIER> <EQUALS> t=<LIT> <RIGHT_SQUARE_BRACKET> )
  {
  		jjtn000.setAnnotation(i.image, t.image);
  })*
  
  <COLUMN_FAMILY>
  t=<IDENTIFIER> 
  <LEFT_BRACE>
  Field()
  (SuperFamily() | DynamicSuperFamily() | Many2Many())+
  <RIGHT_BRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{
		jjtn000.setName(t.image);
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Field()        : {/*@bgen(jjtree) Field */
                        ASTField jjtn000 = new ASTField(JJTFIELD);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; Token i = null; } 
{/*@bgen(jjtree) Field */
  try {
/*@egen*/
  (<LEFT_SQUARE_BRACKET> i=<IDENTIFIER> ( 
	  (<EQUALS> t=<LIT> <RIGHT_SQUARE_BRACKET> )
	  {
	  		jjtn000.setAnnotation(i.image, t.image);
	  } 
  |
	  (<RIGHT_SQUARE_BRACKET>)
	  {
	  		jjtn000.setAnnotation(i.image);
	  }
  ))*
	(t=<BOOLEAN>|t=<BYTE>|t=<BYTESTREAM>|t=<DOUBLE>|t=<FLOAT>|t=<INT>|t=<LONG>|t=<STRING>)
	(i=<IDENTIFIER>)
	<TERM>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		jjtn000.setType(t.image);
		jjtn000.setName(i.image);
	}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SuperFamily()             : {/*@bgen(jjtree) SuperFamily */
                                   ASTSuperFamily jjtn000 = new ASTSuperFamily(JJTSUPERFAMILY);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) SuperFamily */
        try {
/*@egen*/
	<SUPER_FAMILY>
	t=<IDENTIFIER>
	<LEFT_BRACE>
	(Field())+
	<RIGHT_BRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		jjtn000.setName(t.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DynamicSuperFamily()                    : {/*@bgen(jjtree) DynamicSuperFamily */
                                                 ASTDynamicSuperFamily jjtn000 = new ASTDynamicSuperFamily(JJTDYNAMICSUPERFAMILY);
                                                 boolean jjtc000 = true;
                                                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token i = null; Token t = null; }
{/*@bgen(jjtree) DynamicSuperFamily */
        try {
/*@egen*/
	<DYNAMIC_SUPER_FAMILY>
	(t=<BOOLEAN>|t=<BYTE>|t=<BYTESTREAM>|t=<DOUBLE>|t=<FLOAT>|t=<INT>|t=<LONG>|t=<STRING>)
	(i=<IDENTIFIER>)
	<TERM>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		jjtn000.setName(i.image);
		jjtn000.setType(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Many2Many()           : {/*@bgen(jjtree) Many2Many */
                               ASTMany2Many jjtn000 = new ASTMany2Many(JJTMANY2MANY);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token i = null; Token c = null; Token f = null; }
{/*@bgen(jjtree) Many2Many */
        try {
/*@egen*/
	<MANY_2_MANY>
	((c=<IDENTIFIER>)<DOT>(f=<IDENTIFIER>))
	(i=<IDENTIFIER>)
	<TERM>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{
		jjtn000.setColumnFamily(c.image);
		jjtn000.setField(f.image);
		
		jjtn000.setName(i.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
