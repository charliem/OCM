// Automatically Generated by OCM - The Object Cassandra Mapper
//
// Any changes made to this file may be overwritten without warning!


package com.kissintelligentsystems.ocm.java.sample.generated;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Random;

import me.prettyprint.cassandra.service.Keyspace;

import org.apache.cassandra.thrift.*;
import org.apache.thrift.TException;

import com.kissintelligentsystems.ocm.java.BaseTable;
import com.kissintelligentsystems.ocm.java.BaseTableScanner;
import com.kissintelligentsystems.ocm.java.DynamicSuperFamily;
import com.kissintelligentsystems.ocm.java.Many2Many;
import com.kissintelligentsystems.ocm.java.OCMConnection;

@SuppressWarnings("unused")
public class SampleUserColumnFamily extends BaseTable
{
	//Shared Byte arrays of various column and filed names
	private static byte[] familyNameBytes;
	
	//Get each Super Families Name in Bytes
	private static byte[] authSuperNameBytes;
	private static byte[] infoSuperNameBytes;
	private static byte[] rolesSuperNameBytes;

	private static byte[] accountsSuperNameBytes;
	private static byte[] accountsUsersForeignNameBytes;
		
	//Get each Fields name in bytes
	private static byte[] authPasswordNameBytes;
	private static byte[] authSaltNameBytes;
	private static byte[] authEnabledNameBytes;
	private static byte[] infoFirstNameNameBytes;
	private static byte[] infoLastNameNameBytes;
	private static byte[] infoEmailNameBytes;
	
		
	//Key Field
	protected String userID;
		
	//Auth Fields
	protected String password;
	protected String salt;
	protected boolean enabled;

	//Info Fields
	protected String firstName;
	protected String lastName;
	protected String email;

	//Dynamic Super Family Fields
	protected DynamicSuperFamily<String> roles;

	//Many 2 Many Columns
	protected Many2Many<Account> accounts;


	//Field Changed Flags
	private boolean password_Changed = false;
	private boolean salt_Changed = false;
	private boolean enabled_Changed = false;

	private boolean firstName_Changed = false;
	private boolean lastName_Changed = false;
	private boolean email_Changed = false;

	//Original Indexed Fields
	protected String email_Original;

	//The OHM Connection
	private OCMConnection connection;

		
	public SampleUserColumnFamily(OCMConnection connection, String userID)
	{
		//Store the key field
		this.userID = userID;
			
		//Store the connection
		this.connection = connection;
		
		//Initialise all the Dynamic Column Families
		roles = new DynamicSuperFamily<String>();

		//Initialise all the Many 2 Many Columns
		accounts = new Many2Many<Account>();

		//Check if we need to initialise all the shared values
		if(familyNameBytes == null)
		{
			//Convert the Column Family name
			familyNameBytes = fromString("Users");	

			//Convert each super column name
			authSuperNameBytes = fromString("auth");
			infoSuperNameBytes = fromString("info");
			rolesSuperNameBytes = fromString("roles");
			accountsSuperNameBytes = fromString("accounts");
			accountsUsersForeignNameBytes = fromString("users");
			
			//Convert each fields name
			authPasswordNameBytes = fromString("password");
			authSaltNameBytes = fromString("salt");
			authEnabledNameBytes = fromString("enabled");

			infoFirstNameNameBytes = fromString("firstName");
			infoLastNameNameBytes = fromString("lastName");
			infoEmailNameBytes = fromString("email");

		}

	}
		
	@Override
	public void newKey(Random rand) throws Exception
	{
		//Get the DB Interface to generate a new key
		userID = generateNewKey(connection, familyNameBytes, rand);
	}
		

	//Index Accessor Methods
	public static SampleUserColumnFamily tryGetFromEmail(String key, OCMConnection connection) throws Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			keyspace = connection.borrowKeySpace();
				
			//Use the index
			ColumnPath columnPath = new ColumnPath("UsersByEmail");
			columnPath.column = fromString("key");
			
			Column keyCol = keyspace.getColumn(key, columnPath);

			String index = toString(keyCol.getValue());
				
			//Create the new column
			return new SampleUserColumnFamily(connection, index);
		}

		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
		
	public void delete() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				

			//Delete the other side of all the Many 2 Many relationships
			Enumeration<String> enumeration = null;
			

			//Make sure the column is recently loaded
			loadAccounts();

			enumeration = accounts.getColumns().keys();
				
			while (enumeration.hasMoreElements())
			{
				//The Foreign Key
				ColumnPath columnPath = new ColumnPath("Accounts");
				columnPath.setSuper_column(accountsUsersForeignNameBytes);
				columnPath.column = fromString(userID);

				//Remove the foreign key
				keyspace.remove(enumeration.nextElement(), columnPath);
			}

			//Delete the actual row
			keyspace.remove(userID, new ColumnPath("Users"));
			
		}
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public void loadAll() throws IllegalArgumentException, NotFoundException, TException, Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));

			List<SuperColumn> data = keyspace.getSuperSlice(userID, new ColumnParent("Users"), pred);
								
			//Load the fields from the returned data
			loadAll(data);
		}
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	public void loadAll(List<SuperColumn> data)
	{
		Iterator<SuperColumn> iterator = data.iterator();
	
		while(iterator.hasNext())
		{
			//Get each Super Column
			SuperColumn superCol = iterator.next();
		
			if(false)
			{
				//Used to assist code generation
			}
		
			else if(Arrays.equals(superCol.getName(), authSuperNameBytes))
			{
				loadAuth(superCol.getColumns());
			}
			else if(Arrays.equals(superCol.getName(), infoSuperNameBytes))
			{
				loadInfo(superCol.getColumns());
			}
			else if(Arrays.equals(superCol.getName(), rolesSuperNameBytes))
			{
				loadRoles(superCol.getColumns());
			}
			else if(Arrays.equals(superCol.getName(), accountsSuperNameBytes))
			{
				loadAccounts(superCol.getColumns());
			}
		}
	}
	
	

	public void loadAuth() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("Users");
			columnParent.setSuper_column(authSuperNameBytes);

			List<Column> data = keyspace.getSlice(userID, columnParent, pred);
	
			loadAuth(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadAuth(List<Column> cols)
	{

		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();

			if(false)
			{
				//Used to assist code generation
				
			}
	 		else if(Arrays.equals(col.getName(), authPasswordNameBytes))
			{
					password = toString(col.getValue());
					password_Changed = false;
			}
	 		else if(Arrays.equals(col.getName(), authSaltNameBytes))
			{
					salt = toString(col.getValue());
					salt_Changed = false;
			}
	 		else if(Arrays.equals(col.getName(), authEnabledNameBytes))
			{
					enabled = toBoolean(col.getValue());
					enabled_Changed = false;
			}
		}
	}
	

	public void loadInfo() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
				
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("Users");
			columnParent.setSuper_column(infoSuperNameBytes);

			List<Column> data = keyspace.getSlice(userID, columnParent, pred);
	
			loadInfo(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadInfo(List<Column> cols)
	{

		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();

			if(false)
			{
				//Used to assist code generation
				
			}
	 		else if(Arrays.equals(col.getName(), infoFirstNameNameBytes))
			{
					firstName = toString(col.getValue());
					firstName_Changed = false;
			}
	 		else if(Arrays.equals(col.getName(), infoLastNameNameBytes))
			{
					lastName = toString(col.getValue());
					lastName_Changed = false;
			}
	 		else if(Arrays.equals(col.getName(), infoEmailNameBytes))
			{
					email = toString(col.getValue());
					email_Changed = false;

					//Indexed Field
					email_Original = email;
			}
		}
	}

	

	public void loadRoles() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
			
			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("Users");
			columnParent.setSuper_column(rolesSuperNameBytes);

			List<Column> data = keyspace.getSlice(userID, columnParent, pred);

			loadRoles(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadRoles(List<Column> cols)
	{
		Dictionary<String, String> data =  roles.getColumns();
			
		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();
				
			//Add each value
			data.put(toString(col.getName()), toString(col.getValue()));
		}
	}
	

	

	public void loadAccounts() throws Exception 
	{
		Keyspace keyspace = null;
		
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
			

			SlicePredicate pred = new SlicePredicate();
			pred.setSlice_range(new SliceRange(new byte[0], new byte[0], false, 10000));
				
			ColumnParent columnParent = new ColumnParent("Users");
			columnParent.setSuper_column(accountsSuperNameBytes);

			List<Column> data  = keyspace.getSlice(userID, columnParent, pred);
	
			loadAccounts(data);
		}
			
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}
	
	
	private void loadAccounts(List<Column> cols)
	{
		Dictionary<String, Account> data = accounts.getColumns();
			
		Iterator<Column> iterator = cols.iterator();
			
		while(iterator.hasNext())
		{
			Column col = iterator.next();
				
			//Get the key for the other Column Family
			String key = toString(col.getName());
				
			//Get each entry (Don't load it yet thats left to the user)
			Account entry = new Account(connection, key);
				
			//Add the entry
			data.put(key, entry);
		}
	}
	


	@Override
	public void save() throws Exception
	{
		Keyspace keyspace = null;
			
		try
		{
			//Get the Key Space from the Connection Pool
			keyspace = connection.borrowKeySpace();
								
			ArrayList<SuperColumn> sups = new ArrayList<SuperColumn>();
			
			ArrayList<Column> cols = new ArrayList<Column>();
			
			if(password_Changed)
			{
				//Add the changed column
				cols.add(new Column(authPasswordNameBytes, fromString(password), System.currentTimeMillis()));
		
				//Update the changed flag
				password_Changed = false;
			}
			
			if(salt_Changed)
			{
				//Add the changed column
				cols.add(new Column(authSaltNameBytes, fromString(salt), System.currentTimeMillis()));
		
				//Update the changed flag
				salt_Changed = false;
			}
			
			if(enabled_Changed)
			{
				//Add the changed column
				cols.add(new Column(authEnabledNameBytes, fromBoolean(enabled), System.currentTimeMillis()));
		
				//Update the changed flag
				enabled_Changed = false;
			}
			
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(authSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}				
			if(firstName_Changed)
			{
				//Add the changed column
				cols.add(new Column(infoFirstNameNameBytes, fromString(firstName), System.currentTimeMillis()));
		
				//Update the changed flag
				firstName_Changed = false;
			}
			
			if(lastName_Changed)
			{
				//Add the changed column
				cols.add(new Column(infoLastNameNameBytes, fromString(lastName), System.currentTimeMillis()));
		
				//Update the changed flag
				lastName_Changed = false;
			}
			
			if(email_Changed)
			{
				//Add the changed column
				cols.add(new Column(infoEmailNameBytes, fromString(email), System.currentTimeMillis()));
		
				//Update the changed flag
				email_Changed = false;

				ColumnPath columnPath = new ColumnPath("UsersByEmail");
				columnPath.column = fromString("key");

				//Indexed Field
				if(email_Original != null)
				{
					try
					{
						//Remove the old index
						keyspace.remove(email_Original, columnPath);
					}
					catch(Exception exp)
					{
						//Ignore the exception as the key may have already been updated
					}
				}
					
				//Insert the new index
				keyspace.insert(email, columnPath, fromString(userID));
			}
			
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(infoSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}				

			//Update Dynamic Columns
			Iterator<String> dynamicIterator = null;
			Enumeration<String> updatedKeys = null;
			
			dynamicIterator = roles.getDeletedColumns().iterator();

			while(dynamicIterator.hasNext())
			{
				ColumnPath columnPath = new ColumnPath("Users");
				columnPath.setSuper_column(rolesSuperNameBytes);
				columnPath.column = fromString(dynamicIterator.next());

				//Remove the column
				keyspace.remove(userID, columnPath);
			}

			updatedKeys = roles.getUpdatedColumns().keys();

			while(updatedKeys.hasMoreElements())
			{
				String key = updatedKeys.nextElement();
					
				cols.add(new Column(fromString(key), fromString(roles.getColumn(key)), System.currentTimeMillis()));
			}
				
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Clear all the logged updates
				roles.clearPendingUpdates();
			
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(rolesSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}
			

			//Update Many 2 Many Columns
			dynamicIterator = accounts.getDeletedColumns().iterator();

			while(dynamicIterator.hasNext())
			{
				String foreignKey = dynamicIterator.next();
							
				ColumnPath localColumnPath = new ColumnPath("Users");
				localColumnPath.setSuper_column(accountsSuperNameBytes);
				localColumnPath.column = fromString(foreignKey);

				//Remove the column from this column family
				keyspace.remove(userID, localColumnPath);

				ColumnPath foriegnColumnPath = new ColumnPath("Accounts");
				foriegnColumnPath.setSuper_column(accountsUsersForeignNameBytes);
				foriegnColumnPath.column = fromString(userID);
	
				//Remove this item from the other table
				keyspace.remove(foreignKey, foriegnColumnPath);
			}

			updatedKeys = accounts.getUpdatedColumns().keys();

			while(updatedKeys.hasMoreElements())
			{
				String foreignKey = updatedKeys.nextElement();
					
				//Add it to this tables column
				cols.add(new Column(fromString(accounts.get(foreignKey).getKey()), new byte[0], System.currentTimeMillis()));
					
				ColumnPath columnPath = new ColumnPath("Accounts");
				columnPath.setSuper_column(accountsUsersForeignNameBytes);
				columnPath.column = fromString(userID);

				//Add the other tables key to this item					
				keyspace.insert(accounts.get(foreignKey).getKey(), columnPath, new byte[0]);
			}
				
			//Check if there were any changes to this super column
			if(cols.size() > 0)
			{
				//Create a super column to hold the changes
				SuperColumn sup = new SuperColumn(accountsSuperNameBytes, cols);

				//Add the super col to the list of changed supper cols
				sups.add(sup);
				
				//Clear all the logged updates
				accounts.clearPendingUpdates();
					
				//Reset the cols array for the next supper column 
				cols = new ArrayList<Column>();
			}
			

			//Check if there are any new inserts
			if(sups.size() > 0)
			{
				//Send all the value updates to the db
				LinkedHashMap<String, List<SuperColumn>> superMap = new LinkedHashMap<String, List<SuperColumn>>();
					
				//Add all the changes super columns for this Column Family
				superMap.put("Users", sups);
						
				//Send the Batch Insert to the DB Node
				keyspace.batchInsert(userID, null, superMap);
			}
		}
					
		finally
		{
			connection.returnKeySpace(keyspace);
		}
	}

	@Override
	public String getKey()
	{
		return userID;
	}
	
	//Key is read only
	public String getUserID()
	{
		return userID;
	}
		
	//Field Getter and Setters
	public String getPassword()
	{
		return password;
	}
			
	public void setPassword(String password)
	{
		this.password = password;
		
		//Update the changed flag
		password_Changed = true;
	}
	
			
	public String getSalt()
	{
		return salt;
	}
			
	public void setSalt(String salt)
	{
		this.salt = salt;
		
		//Update the changed flag
		salt_Changed = true;
	}
	
			
	public boolean getEnabled()
	{
		return enabled;
	}
			
	public void setEnabled(boolean enabled)
	{
		this.enabled = enabled;
		
		//Update the changed flag
		enabled_Changed = true;
	}
	
			

	public String getFirstName()
	{
		return firstName;
	}
			
	public void setFirstName(String firstName)
	{
		this.firstName = firstName;
		
		//Update the changed flag
		firstName_Changed = true;
	}
	
			
	public String getLastName()
	{
		return lastName;
	}
			
	public void setLastName(String lastName)
	{
		this.lastName = lastName;
		
		//Update the changed flag
		lastName_Changed = true;
	}
	
			
	public String getEmail()
	{
		return email;
	}
			
	public void setEmail(String email)
	{
		this.email = email;
		
		//Update the changed flag
		email_Changed = true;
	}
	
			

	//Dynamic Columns can't be set
	public DynamicSuperFamily<String> getRoles()
	{
		return roles;
	}
	

	//Many 2 Many Columns can't be set
	public Many2Many<Account> getAccounts()
	{
		return accounts;
	}



	public static UserScanner getScanner(OCMConnection connection)
	{
		return new UserScanner(connection);
	}
		
	public static class UserScanner extends BaseTableScanner
	{			
		public UserScanner (OCMConnection connection)
		{
			super(connection, "Users");
		}
			
		public void start(int limit, String key)
		{
			super.startWithStop(limit, key, "");
		}

		public void start(int limit, String startKey, String stopKey)
		{
			super.startWithStop(limit, startKey, stopKey);
		}

		public void start(String key)
		{
			super.startWithStop(-1, key, "");
		}
			
		public void start(String startKey, String stopKey)
		{
			super.startWithStop(-1, startKey, stopKey);
		}
			
			
		public SampleUserColumnFamily tryGetNext() throws IllegalArgumentException, NotFoundException, Exception
		{
			RowData rowData = super.nextRow(); 
				
			if(rowData == null)
				return null;
				
			//Create a new user
			SampleUserColumnFamily result = new SampleUserColumnFamily(connection, rowData.getKey());
				
			//Load the results
			result.loadAll(rowData.getColumns());
								
			return result;
		}		
	}
}
